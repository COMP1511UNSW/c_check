#!/web/cs2041/bin/python3.7.2
import argparse, collections, glob, os, re, sys
import clang.cindex
from clang.cindex import CursorKind as Kind

# source: https://github.com/llvm-mirror/clang/blob/master/bindings/python/clang/cindex.py
# API description: https://www.pydoc.io/pypi/prophy-1.0.1/autoapi/parsers/clang/cindex/index.html#parsers.clang.cindex.Cursor
# example code at: https://github.com/coala/coala-bears/blob/master/bears/c_languages/codeclone_detection/ClangCountingConditions.py


def main():
    args = args_parser()
    global colored
    if args.colorize:
        try:
            from termcolor import colored as colored
        except ImportError:
            colored = lambda x, *args, **kwargs: x
    else:
        colored = lambda x, *args, **kwargs: x

    index_parse_args = get_library_include() + ['-I' + i for i in args.include_directories]

    index = clang.cindex.Index.create()
    n_prohibited_code = 0
    for filename in args.source_files:
        if filename.endswith('.c'):
            n_prohibited_code += check_file(index, filename, args, index_parse_args)
            
    sys.exit(1 if n_prohibited_code else 0)

    
def args_parser():
    parser = argparse.ArgumentParser()

    parser.add_argument("--ban-arrays", dest="ban_arrays", action="store_true", default=False)
    parser.add_argument("--no-ban-arrays", dest="ban_arrays", action="store_false")

    parser.add_argument("--ban-non-char-arrays", dest="ban_non_char_arrays", action="store_true", default=False)
    parser.add_argument("--no-ban-non-char-arrays", dest="ban_non_char_arrays", action="store_false")

    parser.add_argument("--ban-string-library", dest="ban_string_library", action="store_true", default=False)
    parser.add_argument("--no-ban-string-library", dest="ban_string_library", action="store_false")

    parser.add_argument("--ban-multiple-malloc", dest="ban_multiple_malloc", action="store_true", default=False)
    parser.add_argument("--no-multiple-malloc", dest="ban_multiple_malloc", action="store_false")

    parser.add_argument("--ban-goto", dest="ban_goto", action="store_true", default=True)
    parser.add_argument("--ban-no-goto", dest="ban_goto", action="store_false")

    parser.add_argument("--ban-global-variables", dest="ban_global_variables", action="store_true", default=True)
    parser.add_argument("--no-ban-global-variables", dest="ban_global_variables", action="store_false")

    parser.add_argument("--ban-static-local-variables", dest="ban_static_local_variables", action="store_true", default=True)
    parser.add_argument("--no-ban-static-local-variables", dest="ban_static_local_variables", action="store_false")

    parser.add_argument("--check-indenting",  action="store_true", dest="check_indenting", default=True ,  help="check indenting consistent")
    parser.add_argument("--no-check-indenting",  action="store_false", dest="check_indenting", help="do not check indenting consistent")
    
    parser.add_argument("--highlight-incorrect-indenting", action="store_true", dest="highlight_incorrect_indenting", default=True,   help="highlight incorrect indenting")
    parser.add_argument("--no-highlight-incorrect-indenting", action="store_false", dest="highlight_incorrect_indenting", help="do not highlight incorrect indenting")

    parser.add_argument("--colorize", action="store_true", default=os.environ.get('C_CHECK_COLORIZE_OUTPUT', sys.stdout.isatty()), help="colorize output")
    parser.add_argument("--no-colorize", action="store_false", dest='colorize', help="do not colorize output")
    
    parser.add_argument("-I",  dest="include_directories", action="append", default=[], help="add directory for include directories")

    parser.add_argument("-d", "--debug", action="count", default=0 ,  help="show debug ouput")
    parser.add_argument("source_files",  nargs='*', default=[], help="")
    return parser.parse_args()


def get_library_include():
    for library_file in sorted(glob.glob('/usr/lib/x86_64-linux-gnu/libclang-*.so.1'), reverse=True):
        clang_version = re.sub(r'.*libclang-(.*).so.1', r'\1', library_file)
        include_directories = glob.glob(f'/usr/lib/llvm-{clang_version}/lib/clang/{clang_version}*/include/')
        if include_directories:
            clang.cindex.Config.set_library_file(library_file)
            return ["-I" + include_directories[0]]
    return []
    
def check_file(index, C_source_filename, args, index_parse_args):
    try:
        with open(C_source_filename, encoding='utf-8', errors='replace') as f:
            C_source = f.read()
    except OSError as e:
        print(e, file=sys.stderr)
        return 1
    try:
        # using the unsaved_files parameter to avoid rereading the file produces
        # a syntax error with activities/crack_substitution/solutions/crack_substitution.c
        tu = index.parse(C_source_filename, args=index_parse_args)
        for diagnostic in tu.diagnostics:
            if diagnostic.severity in [clang.cindex.Diagnostic.Error, clang.cindex.Diagnostic.Fatal]:
                print(diagnostic.format())
                return 1
            elif args.debug:
                print(diagnostic.format())
        abstract_syntax_tree = tu.cursor
    except clang.cindex.TranslationUnitLoadError:
        return 1

    if args.debug:
        print_ast(abstract_syntax_tree)

    C_source_lines = C_source.splitlines()

    # exit if prohibited code found
    n_prohibited_code = check_prohibited_code(abstract_syntax_tree, args, C_source_lines)
    if n_prohibited_code:
        return n_prohibited_code

    # warn about things like ASCII code
    check_file_expressions(abstract_syntax_tree, args, C_source_lines)
    
    if not args.check_indenting:
        return 0
        
    # exit if tabs and space mixed
    if check_tabs_spaces_mixed(C_source_filename, C_source_lines, abstract_syntax_tree, args):
        return 0

    check_body_indents(C_source_filename, C_source_lines, abstract_syntax_tree, args)
    return 0
    
def check_prohibited_code(abstract_syntax_tree, args, C_source_lines=[]):
    n_always_banned_code = 0
    n_banned_code = 0
    state = {}
    for n in abstract_syntax_tree_nodes(abstract_syntax_tree):
        for check in [ban_global_variables, ban_static_local_variables, ban_goto]:
            description = check(n, args, state)
            if description:
                description += f" - this is {colored('not permitted', 'red')} in COMP1511"
                print_diagnostic(n, description, level='error', source_lines=C_source_lines)
                n_always_banned_code += 1

        for check in [ban_arrays, ban_non_char_arrays, ban_multiple_malloc, ban_string_library]:
            description = check(n, args, state)
            if description:
                description += f" - this is {colored('not permitted', 'red')} in this exercise"
                print_diagnostic(n, description, level='error', source_lines=C_source_lines)
                n_banned_code += 1

    if n_always_banned_code:
        # FIXME -but relative link here
        print("  For more information on C features not permitted in COMP1511 see http://cgi.cse.unsw.edu.au/~cs1511/19T1/resources/style_guide.html")
        print()
        
    return n_always_banned_code + n_banned_code


def print_diagnostic(n, message, level='warning', source_lines=[]):
    print(f"{node_location(n)} {colored(level, 'red')}: {message}")

    line_number = n.extent.start.line
    if line_number != n.extent.end.line:
        # should we display multi-line constructs 
        return
        
    if not line_number or line_number > len(source_lines):
        return

    line = source_lines[line_number - 1]
    start = n.extent.start.column
    end = n.extent.end.column

    if not start or not end:
        return
    if start > len(line) or end > len(line) or start >= end:
        return

    print(line)
    underline = '^' + '~' * (end - start - 1)
    print(' ' * (start - 1) + colored(underline, 'green'))

        
def ban_global_variables(n, args, state):
    if not args.ban_global_variables:
        return None
    #print(n.type.kind, n.type, n.type.spelling, n.type.is_const_qualified())
    if (n.kind == Kind.VAR_DECL and
        n.parent.kind == Kind.TRANSLATION_UNIT and
        'debug' not in n.displayname and 
        'const' not in n.type.spelling): #FIXME - there should be a better way to do this
        return f"variable '{colored(n.displayname, 'blue')}' is a global variable"


def ban_static_local_variables(n, args, state):
    if not args.ban_static_local_variables:
        return None
    if (n.kind == Kind.VAR_DECL and
        n.storage_class == clang.cindex.StorageClass.STATIC and
        'const' not in n.type.spelling): #FIXME - there should be a better way to do this
        return f"variable '{colored(n.displayname, 'blue')}' is declared static"


def ban_goto(n, args, state):
    if not args.ban_goto:
        return None
    if n.kind == Kind.GOTO_STMT:
        return "goto statement used"


def ban_arrays(n, args, state):
    if not args.ban_arrays:
        return None
    if n.kind == Kind.VAR_DECL and '[' in n.type.spelling:
        return "array used"


def ban_non_char_arrays(n, args, state):
    if not args.ban_non_char_arrays:
        return None
    if n.kind == Kind.VAR_DECL and '[' in n.type.spelling and 'char' not in n.type.spelling:
        return "non-char array used"

def ban_multiple_malloc(n, args, state):
    if not args.ban_multiple_malloc:
        return None
    if n.kind == Kind.CALL_EXPR and n.spelling in ['malloc', 'calloc', 'realloc']:
        n_calls = state.get('malloc_calls_count', 0) + 1
        state['malloc_calls_count'] = n_calls
        if n_calls > 1:
            return "malloc called"

def ban_string_library(n, args, state):
    if not args.ban_string_library:
        return None
    if (n.kind == Kind.DECL_REF_EXPR and
        n.referenced and
        n.referenced.location and
        n.referenced.location.file and
        n.referenced.location.file.name == "/usr/include/string.h"):
        return "strings.h used"


def check_file_expressions(abstract_syntax_tree, args, source_lines):
    for function in get_functions(abstract_syntax_tree):
        variables_used_for_chars = set()
        for n in abstract_syntax_tree_nodes(abstract_syntax_tree):
            check_for_raw_ascii_codes(n, args, variables_used_for_chars, source_lines)          


# issue warnings for ASCII codes represented as integer constants,
# e.g.: code like this
#
# int c = getchar();
# if (c == 10) {
#     ....
#
# track variables like which are used toholfd char values
#

def check_for_raw_ascii_codes(n, args, variables_used_for_chars, source_lines):
    if n.kind != Kind.BINARY_OPERATOR:
        return

    variable = test_children(n, is_variable)
    integer_literal = test_children(n, lambda x: x.kind == Kind.INTEGER_LITERAL)
    char_expr = test_children(n, lambda x: is_char_expr(x, variables_used_for_chars))
    operator = get_operator(n)

    if variable and char_expr:
        # note variable has been assigned result of getchar etc.
        variables_used_for_chars.add(variable.hash)

    elif variable and operator == '=':
        # variable previously assigned result of getchar is being reused for different purpose
        # so delete from variables being tracked
        is_variable(next(n.get_children()))
        variables_used_for_chars.discard(variable.hash)

    elif (
        integer_literal and
        operator in ['==', '!=', '<=', '>=', '<', '>'] and
        char_expr):

        #  variable previously assigned result of getchar etc. is  compared to integer literal
        try:
            ascii_code = int(next(integer_literal.get_tokens()).spelling)
        except ValueError:
            ascii_code = 0
        if 6 < ascii_code < 13 or 31 < ascii_code < 126:
            correct = repr(chr(ascii_code))
            message = f"{colored(str(ascii_code), 'red')} used, replace with {colored(correct, 'red')}"
            print_diagnostic(integer_literal, message, level='warning', source_lines=source_lines)
        
def test_children(n, condition): 
    for child in n.get_children():
        value = condition(child)
        if value:
            return child if value is True else value

def is_variable(n):
    while n.kind == Kind.UNEXPOSED_EXPR:
        n = next(n.get_children())
    if n and n.kind == Kind.DECL_REF_EXPR:
        return n.referenced
    
def is_char_expr(n, variables_used_for_chars):
    while n.kind == Kind.UNEXPOSED_EXPR:
        n = next(n.get_children())
    if n and n.type and n.type.spelling == 'char':
        return n
    # these return int, but are char for these purposes
    if n.kind == Kind.CALL_EXPR and n.spelling in ['getchar', 'getc', 'fgetc']:
        return n
    # int variable previously assigned char
    if n and n.kind == Kind.DECL_REF_EXPR and n.referenced.hash in variables_used_for_chars:
        return n

# for some reason n.spelling doesn't contain the operator
# for a binary operator - so use n.extent to find the appropriate token
# we could instead use n.extent to drag the chars from the file
def get_operator(n):
    (left,right) = n.get_children()
    left_end = (left.extent.end.line, left.extent.end.column)
    right_start = (right.extent.start.line, right.extent.start.column)
    #print(left_end, right_start)
    for t in n.get_tokens():
        #print(t.extent.start.line, t.extent.start.column, t.extent.end.line, t.extent.end.column, t.spelling)
        if (
            left_end <= (t.extent.start.line, t.extent.start.column) and
            right_start >= (t.extent.end.line, t.extent.end.column)
            ):
            return t.spelling



# check tabs & spaces not mixed in formatting


def check_tabs_spaces_mixed(C_source_filename, C_source_lines, abstract_syntax_tree, args):
    line_indent_type = collections.defaultdict(lambda:set())
    for (line_number, line) in enumerate(C_source_lines):
        indent_type = categorize_line(line)
        if indent_type:
            line_indent_type[indent_type].add(line_number)

    if line_indent_type['mixed']:
        lines_description = describe_line_set(line_indent_type['mixed'])
        print(
f"""{C_source_filename}: {colored('warning', 'red')}: {lines_description} indented with a mixture of tabs and spaces
  This makes the display of your code unreliable including when your tutor is marking for style.
  In COMP1511 we recommend indenting with spaces only, using 4 spaces per indent level.
  Run {colored('1511 replace_tabs '+ C_source_filename,'blue')} to replace the tabs in {C_source_filename} with spaces.""")
        return 1

    # only warn if tabs and spaced used in same function
    # to avoid warning when student has been supplied code indented with spaces
    # and uses tabs for their own code or vice versa
    
    for function in get_functions(abstract_syntax_tree):
        function_lines = set(range(function.extent.start.line, function.extent.end.line + 1))
        tabbed_lines = function_lines & line_indent_type['tabs']
        spaced_lines = function_lines & line_indent_type['spaces']
        if not tabbed_lines or not spaced_lines:
            continue
        tabbed_description = describe_line_set(tabbed_lines)
        spaced_description = describe_line_set(spaced_lines)
        print(
f"""{C_source_filename}: {colored('warning', 'red')}: function {colored(function.spelling, 'blue')} is indented with a mixture of tabs and spaces:
    {tabbed_description} indented with tabs
    {spaced_description} indented with spaces
  This makes the display of your code unreliable including when your tutor is marking for style.
  In COMP1511 we recommend indenting with spaces only, using 4 spaces per indent level.
  Run {colored('1511 replace_tabs '+ C_source_filename,'blue')} to replace the tabs in {C_source_filename} with spaces.""")
        return 1
        
    return 0

# we could condense ranges here
def describe_line_set(lines):
    max_lines_shown = 5
    line_numbers = sorted(lines)
    description = ",".join(map(str, line_numbers[0:max_lines_shown]))
    if len(line_numbers) == 1:
        return f"line {description} is"
    elif len(line_numbers) > max_lines_shown:
        return f"lines {description}, ... are"
    else:
        return f"lines {description} are"
    
def categorize_line(line):
    if re.match(r'^ +\S', line):
        return "spaces"
    if re.match(r'^\t+\S', line):
        return "tabs"
    if re.match(r'^[ \t]+\S', line):
        return "mixed"  


# check bodies of of if/while/for/functions consistently indented
# This is done per function, to avoid warnings when student has been supplied code
# indented with a different indet to which they use

def check_body_indents(C_source_filename, C_source_lines, abstract_syntax_tree, args):
    line_indent = {}
    show_lines = set()
    for function in get_functions(abstract_syntax_tree):
        show_lines |= check_function_indent(C_source_filename, function, args, line_indent)
    incorrectly_indented_lines = len(show_lines)

    if not incorrectly_indented_lines or not args.highlight_incorrect_indenting:
        return incorrectly_indented_lines

    show_lines = expand_lines_shown(C_source_lines, show_lines)
    
    print_indents(C_source_filename, C_source_lines, args, line_indent, show_lines)
    
    return incorrectly_indented_lines

# determine the indent_unit for a function
# then check lines are consistently indented

def check_function_indent(C_source_filename, abstract_syntax_tree, args, file_line_indent):
    line_indent = {}
    get_indents(abstract_syntax_tree, None, 0, line_indent)
    indent_counts = collections.Counter(i.relative_indent for i in line_indent.values())
    if args.debug:
        print('indent_counts', indent_counts)
    if len(indent_counts) < 2:
        return set()

    # FIXME - change extraction of indent_unit to be per function
    # for small program ensure an indent of 4 has priority
    indent_counts[4] += 2  
    indent_unit = indent_counts.most_common(1)[0][0]
    show_lines = set()
    incorrectly_indented_lines = 0
    for (line, indent) in sorted(line_indent.items()):
        file_line_indent.setdefault(line, indent)
        indent.correct_indent = indent.indent_depth * indent_unit
        if not indent.correctly_indented():
            if not args.highlight_incorrect_indenting: 
                print(f"{C_source_filename}:{line} indented {indent.absolute_indent} should be {indent.correct_indent}")
            incorrectly_indented_lines += 1
            show_lines = show_lines.union(range(indent.parent.extent.start.line, indent.parent.extent.end.line + 1))
    return show_lines
    
# fill in small gaps in lines shown from a file for prettier less confusing output

def expand_lines_shown(C_source_lines, show_lines):
    last_line_number = 0
    for line_number in sorted(show_lines):
        if last_line_number + 1 < line_number < last_line_number + 5:
            show_lines = show_lines.union(range( last_line_number + 1, line_number))
        last_line_number = line_number
    
    if len(C_source_lines) < last_line_number + 5:
        show_lines = show_lines.union(range(last_line_number + 1, len(C_source_lines) + 1))
    return show_lines
    
# display correct/incorrect indents in red/green - idea due to AndrewB

def print_indents(C_source_filename, C_source_lines, args, line_indent, show_lines):
    print(f"{C_source_filename}: {colored('warning', 'red')}: some lines are not consistently indented.")
    print("Incorrectly indented lines are marked with an *.", end='')
    if args.colorize:
        print(f" The correct indent is {colored('shown in red', on_color='on_red')}.")
        print(f"Correctly indented lines are {colored('shown in green', on_color='on_green')}.", end='')
    print()
    last_line_number = 0
    for line_number in sorted(show_lines):
        if last_line_number and line_number > last_line_number + 5:
            print('......')
        line = C_source_lines[line_number - 1]
        print(f'{line_number:6}', end='')
        if line_number in line_indent:
            print(line_indent[line_number].get_indent_string(line))
        else:
            print(' ', line)
        last_line_number = line_number

def get_indents(n, parent, indent_depth, line_indent):
    n.parent = parent
    #print(f'{n.location.file}:{n.extent.start.line}:{n.extent.start.column} {n.kind.name} {n.spelling}')
    if n.kind == Kind.COMPOUND_STMT:
        if parent.kind not in [Kind.IF_STMT, Kind.WHILE_STMT, Kind.FOR_STMT, Kind.FUNCTION_DECL]:
            return
        # handle if else if chains
        while parent.parent and parent.parent.kind == Kind.IF_STMT:
            parent = parent.parent
        for child in n.get_children():
            li = Indent(
                relative_indent = child.extent.start.column - parent.extent.start.column,
                absolute_indent = child.extent.start.column - 1,
                indent_depth = indent_depth + 1,
                parent = parent)
            line_indent.setdefault(child.extent.start.line, li)
            get_indents(child, n, indent_depth + 1 , line_indent)
        closing_brace = Indent(
            relative_indent = n.extent.end.column - parent.extent.start.column - 1,
            absolute_indent = n.extent.end.column - 2,
            indent_depth = indent_depth,
            parent = parent)
        line_indent.setdefault(n.extent.end.line, closing_brace)
    else:
        parent_filename = n.location.file.name if n.location.file else n.displayname
        for child in n.get_children():
            child_filename = child.location.file.name if child.location.file else child.displayname
            if child_filename == parent_filename:
                get_indents(child, n, indent_depth, line_indent)
            
class Indent():
    def __init__(self, absolute_indent=None, relative_indent=None, indent_depth=None, parent=None):
        self.absolute_indent = absolute_indent
        self.relative_indent = relative_indent
        self.indent_depth = indent_depth
        self.parent = parent
        self.correct_indent = None # calculated later
        
    def correctly_indented(self):
        return self.correct_indent == self.absolute_indent

    def get_indent_string(self, line):
        if self.correctly_indented():
            on_color = 'on_green'
            marker = ' ' 
        else:
            on_color = 'on_red'
            marker = '*'
        if len(line) < self.correct_indent:
            line += ' ' * (self.correct_indent - len(line))
        prefix = line[0:self.correct_indent]
        suffix = line[self.correct_indent:]
        return f'{marker} {colored(prefix, on_color=on_color)}{suffix}'

# traverse ast nodes from same file (don't go into #includes)
# semantic_parent & lexical parents don't seem to be implement so add own our parent & depth
def abstract_syntax_tree_nodes(node, depth=0, parent=None):
    node.depth = depth
    node.parent = parent
    yield node
    parent_filename = node.location.file.name if node.location.file else node.displayname
    for child in node.get_children():
        child_filename = child.location.file.name if child.location.file else child.displayname
        if  child_filename == parent_filename:
            for rn in abstract_syntax_tree_nodes(child, depth + 1, node):
                yield rn

def get_functions(root):
    for function in root.get_children():
        if (function.kind != Kind.FUNCTION_DECL or
            not function.location.file or
            function.location.file.name != root.displayname or
            # skip declarations
            not any(c.kind == Kind.COMPOUND_STMT for c in function.get_children())):
            continue
        yield function
        
def print_ast(node):
    for n in abstract_syntax_tree_nodes(node):
        print(' ' * n.depth, end='')
        print(f"{n.location.file}:{n.extent.start.line}:{n.extent.start.column} {n.kind.name} spelling='{n.spelling}' type='{n.type.spelling}'")
        
def node_location(n):
    return f'{n.location.file}:{n.extent.start.line}:{n.extent.start.column}'

def dump(obj):
    for attr in dir(obj):
        try:
            print("obj.%s = %r" % (attr, getattr(obj, attr)))
        except Exception:
            pass

        
if __name__ == "__main__":
    try:
        sys.exit(1 if main() else 0)
    except KeyboardInterrupt:
        sys.exit(2)
