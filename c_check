#!/web/cs2041/bin/python3.7.2
import argparse, collections, os, re, sys
import clang.cindex
from clang.cindex import CursorKind as Kind

# https://github.com/llvm-mirror/clang/blob/master/bindings/python/clang/cindex.py
# https://www.pydoc.io/pypi/prophy-1.0.1/autoapi/parsers/clang/cindex/index.html#parsers.clang.cindex.Cursor

def main():
	clang.cindex.Config.set_library_file('/usr/lib/x86_64-linux-gnu/libclang-7.so.1')
	args = args_parser()
	global colored
	if args.colorize:
		try:
			from termcolor import colored as colored
		except ImportError:
			colored = lambda x, *args, **kwargs: x
	else:
		colored = lambda x, *args, **kwargs: x
	index = clang.cindex.Index.create()
	n_warnings = 0
	for filename in args.source_files:
		if filename.endswith('.c'):
			n_warnings += check_file(index, filename, args)
	return n_warnings
	
def args_parser():
	parser = argparse.ArgumentParser()
	parser.add_argument("--colorize", action="store_true", default=os.environ.get('C_CHECK_COLORIZE_OUTPUT', sys.stdout.isatty()), help="colorize output")
	parser.add_argument("-d", "--debug", action="count", default=0 ,  help="show debug ouput")
	parser.add_argument("-i", "--indenting", action="count", default=0 ,  help="check indeting conistant")
	parser.add_argument("source_files",	 nargs='*', default=[], help="")
	return parser.parse_args()

def check_file(index, C_source_filename, args):
	try:
		with open(C_source_filename, encoding='utf-8', errors='replace') as f:
			C_source = f.read()
	except OSError as e:
		print(e, file=sys.stderr)
		return 1
	try:
		tu = index.parse(C_source_filename, args=["-I/usr/lib/llvm-7/lib/clang/7.0.1/include/"], unsaved_files=[(C_source_filename, C_source)])
		for diagnostic in tu.diagnostics:
			if diagnostic.severity in [clang.cindex.Diagnostic.Error, clang.cindex.Diagnostic.Fatal]:
				print(diagnostic.format())
				sys.exit(1)
		abstract_syntax_tree = tu.cursor
	except clang.cindex.TranslationUnitLoadError:
		return 1
	if args.debug:
		for n in abstract_syntax_tree_nodes(abstract_syntax_tree):
			print(f'{" " * n.depth} {n.kind.name} {node_location(n)}')
	n_warnings = check_prohibited_code(abstract_syntax_tree, args)
	if n_warnings:
		return n_warnings
	C_source_lines = C_source.splitlines()
	# exit 0 for indent warning
	if check_tabs_spaces_mixed(C_source_filename, C_source_lines, abstract_syntax_tree, args):
		return 0
	if args.indenting:
		check_body_indents(C_source_filename, C_source_lines, abstract_syntax_tree, args)
	return 0
	
def check_prohibited_code(abstract_syntax_tree, args):
	n_warnings = 0
	for n in abstract_syntax_tree_nodes(abstract_syntax_tree):
		for check in [check_global, check_static, check_goto]:
			description = check(n)
			if description:
				print(f"{node_location(n)} {colored('warning', 'red')}: {description} - this is {colored('not permitted', 'red')} in COMP1511")
				n_warnings += 1
	if n_warnings:
		# FIXME
		print("  For more information see http://cgi.cse.unsw.edu.au/~cs1511/19T1/flask_tutors.cgi/resources/style_guide.html")
		print()
	return n_warnings

def check_global(node):
	if (node.kind == Kind.VAR_DECL and
		node.parent.kind == Kind.TRANSLATION_UNIT and
		not node.type.is_const_qualified() and
		node.type.kind != clang.cindex.TypeKind.CONSTANTARRAY):
		return f"variable '{colored(node.displayname, 'blue')}' is a global variable"

def check_static(node):
	if node.kind == Kind.VAR_DECL and node.storage_class == clang.cindex.StorageClass.STATIC:
		return f"variable '{colored(node.displayname, 'blue')}' is declared static"

def check_goto(node):
	if node.kind == Kind.GOTO_STMT:
		return f"goto statement used"

def check_tabs_spaces_mixed(C_source_filename, C_source_lines, abstract_syntax_tree, args):
	line_indent_type = collections.defaultdict(lambda:set())
	for (line_number, line) in enumerate(C_source_lines):
		indent_type = categorize_line(line)
		if indent_type:
			line_indent_type[indent_type].add(line_number)

	if line_indent_type['mixed']:
		lines_description = describe_line_set(line_indent_type['mixed'])
		print(
f"""{C_source_filename}: {colored('warning', 'red')}: {lines_description} indented with a mixture of tabs and spaces
  This makes the display of your code unreliable including when your tutor is marking for style.
  In COMP1511 we recommend indenting with spaces only, using 4 spaces per indent level.
  Run {colored('1511 replace_tabs '+ C_source_filename,'blue')} to replace the tabs in {C_source_filename} with spaces.""")
		return 1

	# only warn if tabs and spaced used in same function
	# to avoid warning when student has been supplied code indented with spaces
	# and uses tabs for their own code 
	for function in abstract_syntax_tree.get_children():
		if (function.kind != Kind.FUNCTION_DECL or
			not function.location.file or
			function.location.file != C_source_filename):
			continue
		function_lines = set(range(function.extent.start.line, function.extent.end.line + 1))
		tabbed_lines = function_lines & line_indent_type['tabs']
		spaced_lines = function_lines & line_indent_type['spaces']
		if not tabbed_lines or not spaced_lines:
			continue
		tabbed_description = describe_line_set(tabbed_lines)
		spaced_description = describe_line_set(spaced_lines)
		print(
f"""{C_source_filename}: {colored('warning', 'red')}: function {colored(function.spelling, 'blue')} is indented with a mixture of tabs and spaces:
	{tabbed_description} indented with tabs
	{spaced_description} indented with spaces
  This makes the display of your code unreliable including when your tutor is marking for style.
  In COMP1511 we recommend indenting with spaces only, using 4 spaces per indent level.
  Run {colored('1511 replace_tabs '+ C_source_filename,'blue')} to replace the tabs in {C_source_filename} with spaces.""")
		return 1
		
	return 0

# we could condense ranges here
def describe_line_set(lines):
	max_lines_shown = 5
	line_numbers = sorted(lines)
	description = ",".join(map(str, line_numbers[0:max_lines_shown]))
	if len(line_numbers) == 1:
		return f"line {description} is"
	elif len(line_numbers) > max_lines_shown:
		return f"lines {description}, ... are"
	else:
		return f"lines {description} are"
	
def categorize_line(line):
	if re.match(r'^ +\S', line):
		return "spaces"
	if re.match(r'^\t+\S', line):
		return "tabs"
	if re.match(r'^[ \t]+\S', line):
		return "mixed"	
	
# check bodies of of if/while/for functions consistently indented
# mixes of tabs & spaces not considered
def check_body_indents(C_source_filename, C_source_lines, abstract_syntax_tree, args):
	line_indent = {}
	get_indents_node(abstract_syntax_tree, None, 0, line_indent)
	indent_counts = collections.Counter(i[0] for i in line_indent.values() if i[0])
	if len(indent_counts) < 2:
		return

	# FIXME - change extraction of base_indent to be per function
	# for small program ensure an indent of 4 has priority
	indent_counts[4] += 2  
	base_indent = indent_counts.most_common(1)[0][0]
	show_lines = set()
	incorrectly_indented_lines = 0
	for (line, (relative_indent, absolute_indent, indent_depth, parent)) in sorted(line_indent.items()):
		if absolute_indent != indent_depth * base_indent:
			if args.debug: 
				print(f"{C_source_filename}:{line} indented {absolute_indent} should be {indent_depth * base_indent}")
				print(parent.extent.start.line, parent.extent.end.line + 1)
			incorrectly_indented_lines += 1
			show_lines = show_lines.union(range(parent.extent.start.line, parent.extent.end.line + 1))

	last_line_number = 0
	for line_number in sorted(show_lines):
		if last_line_number + 1 < line_number < last_line_number + 5:
			show_lines = show_lines.union(range( last_line_number + 1, line_number))
		last_line_number = line_number
	
	if len(C_source_lines) < last_line_number + 5:
		show_lines = show_lines.union(range(last_line_number + 1, len(C_source_lines) + 1))
		
	print(f"{C_source_filename}: {colored('warning', 'red')}: some lines are not consistently indented.")
	print("Incorrectly indented lines are marked with an *.", end='')
	if args.colorize:
		print(f" The correct indent is {colored('shown in red', on_color='on_red')}.")
		print(f"Correctly indented lines are {colored('shown in green', on_color='on_green')}.", end='')
	print()
	last_line_number = 0
	for line_number in sorted(show_lines):
		if last_line_number and line_number > last_line_number + 5:
			print('......')
		line = C_source_lines[line_number - 1]
		if line_number in line_indent:
			(relative_indent, absolute_indent, indent_depth, parent) = line_indent[line_number]
			correct_indent = indent_depth * base_indent
			on_color = 'on_green' if absolute_indent == correct_indent else 'on_red'
			marker = ' ' if absolute_indent == correct_indent else '*'
			if len(line) < correct_indent:
				line += ' ' * (correct_indent - len(line))
			prefix = line[0:correct_indent]
			suffix = line[correct_indent:]
			print(f'{line_number:6}{marker} {colored(prefix, on_color=on_color)}{suffix}')
		else:
			print(f'{line_number:6}  {line}')
		last_line_number = line_number

	return incorrectly_indented_lines
		
def get_indents_node(n, parent, indent_depth, line_indent):
	n.parent = parent
	#print(f'{"	 " * n.depth} {n.kind.name} {n.location.file}:{n.extent.start.line}:{n.extent.start.column}')
	if n.kind == Kind.COMPOUND_STMT:
		if parent.kind not in [Kind.IF_STMT, Kind.WHILE_STMT, Kind.FOR_STMT, Kind.FUNCTION_DECL]:
			return
		# handle if else if chains
		while parent.parent.kind == Kind.IF_STMT:
			parent = parent.parent
		for child in n.get_children():
			child_line_number = child.extent.start.line
			relative_indent = child.extent.start.column - parent.extent.start.column
			absolute_indent = child.extent.start.column - 1
			tuple = (relative_indent, absolute_indent, indent_depth + 1, parent)
			line_indent.setdefault(child_line_number, tuple)
			get_indents_node(child, n, indent_depth + 1 , line_indent)
		end_line_number = n.extent.end.line
		relative_indent = n.extent.end.column - parent.extent.start.column - 1
		absolute_indent = n.extent.end.column - 2
		tuple = (relative_indent, absolute_indent, indent_depth, parent)
		line_indent.setdefault(end_line_number, tuple)
	else:
		parent_filename = n.location.file.name if n.location.file else n.displayname
		for child in n.get_children():
			child_filename = child.location.file.name if child.location.file else child.displayname
			if child_filename == parent_filename:
				get_indents_node(child, n, indent_depth, line_indent)
			
# traverse ast nodes from same file (don't go into #includes)
# semantic_parent & lexical parents don't seem to be implement so add own our parent & depth
def abstract_syntax_tree_nodes(node, depth=0, parent=None):
	node.depth = depth
	node.parent = parent
	yield node
	parent_filename = node.location.file.name if node.location.file else node.displayname
	for child in node.get_children():
		child_filename = child.location.file.name if child.location.file else child.displayname
		if  child_filename == parent_filename:
			for rn in abstract_syntax_tree_nodes(child, depth + 1, node):
				yield rn

def node_location(n):
	return f'{n.location.file}:{n.extent.start.line}:{n.extent.start.column}'
	
if __name__ == "__main__":
	try:
		sys.exit(1 if main() else 0)
	except KeyboardInterrupt:
		sys.exit(2)
