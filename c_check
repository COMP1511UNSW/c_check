#!/web/cs2041/bin/python3.7.2
import argparse, collections, glob, os, re, sys
import clang.cindex
from clang.cindex import CursorKind as Kind

# https://github.com/llvm-mirror/clang/blob/master/bindings/python/clang/cindex.py
# https://www.pydoc.io/pypi/prophy-1.0.1/autoapi/parsers/clang/cindex/index.html#parsers.clang.cindex.Cursor

def main():
	include_directory = None
	index_parse_args = []
	for library_file in sorted(glob.glob('/usr/lib/x86_64-linux-gnu/libclang-*.so.1'), reverse=True):
		clang_version = re.sub(r'.*libclang-(.*).so.1', r'\1', library_file)
		include_directories = glob.glob(f'/usr/lib/llvm-{clang_version}/lib/clang/{clang_version}*/include/')
		if include_directories:
			include_directory = include_directories[0]
			break
	if include_directory:
		clang.cindex.Config.set_library_file(library_file)
		index_parse_args = ["-I"+include_directory]
	args = args_parser()
	global colored
	if args.colorize:
		try:
			from termcolor import colored as colored
		except ImportError:
			colored = lambda x, *args, **kwargs: x
	else:
		colored = lambda x, *args, **kwargs: x
	index = clang.cindex.Index.create()
	n_warnings = 0
	for filename in args.source_files:
		if filename.endswith('.c'):
			n_warnings += check_file(index, filename, args, index_parse_args)
	return n_warnings
	
def args_parser():
	parser = argparse.ArgumentParser()
	parser.add_argument("--colorize", action="store_true", default=os.environ.get('C_CHECK_COLORIZE_OUTPUT', sys.stdout.isatty()), help="colorize output")
	parser.add_argument("-d", "--debug", action="count", default=0 ,  help="show debug ouput")
	parser.add_argument("--no_indenting",  action="store_false", dest="indenting", default=True ,  help="check indenting consistent")
	parser.add_argument("--no_highlight_incorrect_indenting", action="store_false", dest="highlight_incorrect_indenting", default=True,   help="do not highlight incorrect indenting")
	parser.add_argument("source_files",	 nargs='*', default=[], help="")
	return parser.parse_args()

def check_file(index, C_source_filename, args, index_parse_args):
	try:
		with open(C_source_filename, encoding='utf-8', errors='replace') as f:
			C_source = f.read()
	except OSError as e:
		print(e, file=sys.stderr)
		return 1
	try:
		# using the unsaved_files parameter to avoid rereading the file produces
		# a syntax error with activities/crack_substitution/solutions/crack_substitution.c
		tu = index.parse(C_source_filename, args=index_parse_args)
		for diagnostic in tu.diagnostics:
			if diagnostic.severity in [clang.cindex.Diagnostic.Error, clang.cindex.Diagnostic.Fatal]:
				print(diagnostic.format())
				sys.exit(1)
			elif args.debug:
				print(diagnostic.format())
		abstract_syntax_tree = tu.cursor
	except clang.cindex.TranslationUnitLoadError:
		return 1
	if args.debug:
		for n in abstract_syntax_tree_nodes(abstract_syntax_tree):
			print(f'{" " * n.depth} {n.kind.name} {node_location(n)}')
	n_warnings = check_prohibited_code(abstract_syntax_tree, args)
	if n_warnings:
		return n_warnings
	C_source_lines = C_source.splitlines()
	# exit 0 for indent warning
	if check_tabs_spaces_mixed(C_source_filename, C_source_lines, abstract_syntax_tree, args):
		return 0
	if args.indenting:
		check_body_indents(C_source_filename, C_source_lines, abstract_syntax_tree, args)
	return 0
	
def check_prohibited_code(abstract_syntax_tree, args):
	n_warnings = 0
	for n in abstract_syntax_tree_nodes(abstract_syntax_tree):
		for check in [check_global, check_static, check_goto]:
			description = check(n)
			if description:
				print(f"{node_location(n)} {colored('warning', 'red')}: {description} - this is {colored('not permitted', 'red')} in COMP1511")
				n_warnings += 1
	if n_warnings:
		# FIXME
		print("  For more information see http://cgi.cse.unsw.edu.au/~cs1511/19T1/flask_tutors.cgi/resources/style_guide.html")
		print()
	return n_warnings

def check_global(node):
	#print(node.type.kind, node.type, node.type.spelling, node.type.is_const_qualified())
	if (node.kind == Kind.VAR_DECL and
		node.parent.kind == Kind.TRANSLATION_UNIT and
		'debug' not in node.displayname and 
		'const' not in node.type.spelling): #FIXME - there should be a better way to do this
		return f"variable '{colored(node.displayname, 'blue')}' is a global variable"

def check_static(node):
	if node.kind == Kind.VAR_DECL and node.storage_class == clang.cindex.StorageClass.STATIC:
		return f"variable '{colored(node.displayname, 'blue')}' is declared static"

def check_goto(node):
	if node.kind == Kind.GOTO_STMT:
		return f"goto statement used"

def check_tabs_spaces_mixed(C_source_filename, C_source_lines, abstract_syntax_tree, args):
	line_indent_type = collections.defaultdict(lambda:set())
	for (line_number, line) in enumerate(C_source_lines):
		indent_type = categorize_line(line)
		if indent_type:
			line_indent_type[indent_type].add(line_number)

	if line_indent_type['mixed']:
		lines_description = describe_line_set(line_indent_type['mixed'])
		print(
f"""{C_source_filename}: {colored('warning', 'red')}: {lines_description} indented with a mixture of tabs and spaces
  This makes the display of your code unreliable including when your tutor is marking for style.
  In COMP1511 we recommend indenting with spaces only, using 4 spaces per indent level.
  Run {colored('1511 replace_tabs '+ C_source_filename,'blue')} to replace the tabs in {C_source_filename} with spaces.""")
		return 1

	# only warn if tabs and spaced used in same function
	# to avoid warning when student has been supplied code indented with spaces
	# and uses tabs for their own code or vice versa
	for function in get_functions(abstract_syntax_tree):
		function_lines = set(range(function.extent.start.line, function.extent.end.line + 1))
		tabbed_lines = function_lines & line_indent_type['tabs']
		spaced_lines = function_lines & line_indent_type['spaces']
		if not tabbed_lines or not spaced_lines:
			continue
		tabbed_description = describe_line_set(tabbed_lines)
		spaced_description = describe_line_set(spaced_lines)
		print(
f"""{C_source_filename}: {colored('warning', 'red')}: function {colored(function.spelling, 'blue')} is indented with a mixture of tabs and spaces:
	{tabbed_description} indented with tabs
	{spaced_description} indented with spaces
  This makes the display of your code unreliable including when your tutor is marking for style.
  In COMP1511 we recommend indenting with spaces only, using 4 spaces per indent level.
  Run {colored('1511 replace_tabs '+ C_source_filename,'blue')} to replace the tabs in {C_source_filename} with spaces.""")
		return 1
		
	return 0

# we could condense ranges here
def describe_line_set(lines):
	max_lines_shown = 5
	line_numbers = sorted(lines)
	description = ",".join(map(str, line_numbers[0:max_lines_shown]))
	if len(line_numbers) == 1:
		return f"line {description} is"
	elif len(line_numbers) > max_lines_shown:
		return f"lines {description}, ... are"
	else:
		return f"lines {description} are"
	
def categorize_line(line):
	if re.match(r'^ +\S', line):
		return "spaces"
	if re.match(r'^\t+\S', line):
		return "tabs"
	if re.match(r'^[ \t]+\S', line):
		return "mixed"	

# check bodies of of if/while/for/functions consistently indented
# This is done per function, to avoid warnings when student has been supplied code
# indented with a different indet to which they use

def check_body_indents(C_source_filename, C_source_lines, abstract_syntax_tree, args):
	line_indent = {}
	show_lines = set()
	for function in get_functions(abstract_syntax_tree):
		show_lines |= check_function_indent(C_source_filename, function, args, line_indent)
	incorrectly_indented_lines = len(show_lines)

	if not incorrectly_indented_lines or not args.highlight_incorrect_indenting:
		return incorrectly_indented_lines

	show_lines = expand_lines_shown(C_source_lines, show_lines)
	
	print_indents(C_source_filename, C_source_lines, args, line_indent, show_lines)
	
	return incorrectly_indented_lines

# determine the indent_unit for a function
# then check lines are consistently indented

def check_function_indent(C_source_filename, abstract_syntax_tree, args, file_line_indent):
	line_indent = {}
	get_indents(abstract_syntax_tree, None, 0, line_indent)
	indent_counts = collections.Counter(i.relative_indent for i in line_indent.values() if i.relative_indent)
	if args.debug:
		print('indent_counts', indent_counts)
	if len(indent_counts) < 2:
		return set()

	# FIXME - change extraction of indent_unit to be per function
	# for small program ensure an indent of 4 has priority
	indent_counts[4] += 2  
	indent_unit = indent_counts.most_common(1)[0][0]
	show_lines = set()
	incorrectly_indented_lines = 0
	for (line, indent) in sorted(line_indent.items()):
		file_line_indent.setdefault(line, indent)
		indent.correct_indent = indent.indent_depth * indent_unit
		if not indent.correctly_indented():
			if not args.highlight_incorrect_indenting: 
				print(f"{C_source_filename}:{line} indented {indent.absolute_indent} should be {indent.correct_indent}")
			incorrectly_indented_lines += 1
			show_lines = show_lines.union(range(indent.parent.extent.start.line, indent.parent.extent.end.line + 1))
	return show_lines
	
# fill in small gaps in line shown for prettier less confusing output

def expand_lines_shown(C_source_lines, show_lines):
	last_line_number = 0
	for line_number in sorted(show_lines):
		if last_line_number + 1 < line_number < last_line_number + 5:
			show_lines = show_lines.union(range( last_line_number + 1, line_number))
		last_line_number = line_number
	
	if len(C_source_lines) < last_line_number + 5:
		show_lines = show_lines.union(range(last_line_number + 1, len(C_source_lines) + 1))
	return show_lines
	
# display correct/incorrect indents in red/green - idea due to AndrewB

def print_indents(C_source_filename, C_source_lines, args, line_indent, show_lines):
	print(f"{C_source_filename}: {colored('warning', 'red')}: some lines are not consistently indented.")
	print("Incorrectly indented lines are marked with an *.", end='')
	if args.colorize:
		print(f" The correct indent is {colored('shown in red', on_color='on_red')}.")
		print(f"Correctly indented lines are {colored('shown in green', on_color='on_green')}.", end='')
	print()
	last_line_number = 0
	for line_number in sorted(show_lines):
		if last_line_number and line_number > last_line_number + 5:
			print('......')
		line = C_source_lines[line_number - 1]
		print(f'{line_number:6}', end='')
		if line_number in line_indent:
			print(line_indent[line_number].get_indent_string(line))
		else:
			print(' ', line)
		last_line_number = line_number

def get_indents(n, parent, indent_depth, line_indent):
	n.parent = parent
	#print(f'{n.location.file}:{n.extent.start.line}:{n.extent.start.column} {n.kind.name} {n.spelling}')
	if n.kind == Kind.COMPOUND_STMT:
		if parent.kind not in [Kind.IF_STMT, Kind.WHILE_STMT, Kind.FOR_STMT, Kind.FUNCTION_DECL]:
			return
		# handle if else if chains
		while parent.parent and parent.parent.kind == Kind.IF_STMT:
			parent = parent.parent
		for child in n.get_children():
			li = Indent(
				relative_indent = child.extent.start.column - parent.extent.start.column,
				absolute_indent = child.extent.start.column - 1,
				indent_depth = indent_depth + 1,
				parent = parent)
			line_indent.setdefault(child.extent.start.line, li)
			get_indents(child, n, indent_depth + 1 , line_indent)
		closing_brace = Indent(
			relative_indent = n.extent.end.column - parent.extent.start.column - 1,
			absolute_indent = n.extent.end.column - 2,
			indent_depth = indent_depth,
			parent = parent)
		line_indent.setdefault(n.extent.end.line, closing_brace)
	else:
		parent_filename = n.location.file.name if n.location.file else n.displayname
		for child in n.get_children():
			child_filename = child.location.file.name if child.location.file else child.displayname
			if child_filename == parent_filename:
				get_indents(child, n, indent_depth, line_indent)
			
class Indent():
	def __init__(self, absolute_indent=None, relative_indent=None, indent_depth=None, parent=None):
		self.absolute_indent = absolute_indent
		self.relative_indent = relative_indent
		self.indent_depth = indent_depth
		self.parent = parent
		self.correct_indent = None # calculated later
		
	def correctly_indented(self):
		return self.correct_indent == self.absolute_indent

	def get_indent_string(self, line):
		if self.correctly_indented():
			on_color = 'on_green'
			marker = ' ' 
		else:
			on_color = 'on_red'
			marker = '*'
		if len(line) < self.correct_indent:
			line += ' ' * (self.correct_indent - len(line))
		prefix = line[0:self.correct_indent]
		suffix = line[self.correct_indent:]
		return f'{marker} {colored(prefix, on_color=on_color)}{suffix}'

# traverse ast nodes from same file (don't go into #includes)
# semantic_parent & lexical parents don't seem to be implement so add own our parent & depth
def abstract_syntax_tree_nodes(node, depth=0, parent=None):
	node.depth = depth
	node.parent = parent
	yield node
	parent_filename = node.location.file.name if node.location.file else node.displayname
	for child in node.get_children():
		child_filename = child.location.file.name if child.location.file else child.displayname
		if  child_filename == parent_filename:
			for rn in abstract_syntax_tree_nodes(child, depth + 1, node):
				yield rn

def get_functions(root):
	for function in root.get_children():
		if (function.kind != Kind.FUNCTION_DECL or
			not function.location.file or
			function.location.file.name != root.displayname or
			# skip declarations
			not any(c.kind == Kind.COMPOUND_STMT for c in function.get_children())):
			continue
		yield function
		
def node_location(n):
	return f'{n.location.file}:{n.extent.start.line}:{n.extent.start.column}'
	
if __name__ == "__main__":
	try:
		sys.exit(1 if main() else 0)
	except KeyboardInterrupt:
		sys.exit(2)
