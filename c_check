#!/web/cs2041/bin/python3.7.2
import argparse, collections, os, re, sys
import clang.cindex
from clang.cindex import CursorKind as Kind

# https://github.com/llvm-mirror/clang/blob/master/bindings/python/clang/cindex.py
# https://www.pydoc.io/pypi/prophy-1.0.1/autoapi/parsers/clang/cindex/index.html#parsers.clang.cindex.Cursor

def main():
	clang.cindex.Config.set_library_file('/usr/lib/x86_64-linux-gnu/libclang-7.so.1')
	args = args_parser()
	global colored
	if args.colorize:
		try:
			from termcolor import colored as colored
		except ImportError:
			colored = lambda x, *args, **kwargs: x
	else:
		colored = lambda x, *args, **kwargs: x
	index = clang.cindex.Index.create()
	n_warnings = 0
	for filename in args.source_files:
		if filename.endswith('.c'):
			n_warnings += check_file(index, filename, args)
	return n_warnings
	
def check_file(index, C_source_filename, args):
	try:
		with open(C_source_filename, encoding='utf-8', errors='replace') as f:
			C_source = f.read()
	except OSError as e:
		print(e, file=sys.stderr)
		return
	try:
		abstract_syntax_tree = index.parse(C_source_filename, unsaved_files=[(C_source_filename, C_source)]).cursor
	except clang.cindex.TranslationUnitLoadError:
		return
	if args.debug:
		for n in abstract_syntax_tree_nodes(abstract_syntax_tree):
			print(f'{" " * n.depth} {n.kind.name} {node_location(n)}')
	n_warnings = check_prohibited_code(abstract_syntax_tree, args)
	if n_warnings:
		return n_warnings
	C_source_lines = C_source.splitlines()
	if check_tabs_spaces_mixed(C_source_filename, C_source_lines, abstract_syntax_tree, args):
		return 0 # exit 0 for indent warnings
	return 0
#	check_body_indents(args, C_source_filename, C_source)

def args_parser():
	parser = argparse.ArgumentParser()
	parser.add_argument("--colorize", action="store_true", default=os.environ.get('C_CHECK_COLORIZE_OUTPUT', sys.stdout.isatty()), help="colorize output")
	parser.add_argument("-d", "--debug", action="count", default=0 ,  help="show debug ouput")
	parser.add_argument("source_files",	 nargs='*', default=[], help="")
	return parser.parse_args()

def check_prohibited_code(abstract_syntax_tree, args):
	n_warnings = 0
	for n in abstract_syntax_tree_nodes(abstract_syntax_tree):
		for check in [check_global, check_static, check_goto]:
			description = check(n)
			if description:
				print(f"{node_location(n)} {colored('warning', 'red')}: {description} - this is {colored('not permitted', 'red')} in COMP1511")
				n_warnings += 1
	if n_warnings:
		# FIXME
		print("  For more information see http://cgi.cse.unsw.edu.au/~cs1511/19T1/flask_tutors.cgi/resources/style_guide.html")
		print()
	return n_warnings

def check_global(node):
	if (node.kind == Kind.VAR_DECL and
		node.parent.kind == Kind.TRANSLATION_UNIT and
		not node.type.is_const_qualified() and
		node.type.kind != clang.cindex.TypeKind.CONSTANTARRAY):
		return f"variable '{colored(node.displayname, 'blue')}' is a global variable"

def check_static(node):
	if node.kind == Kind.VAR_DECL and node.storage_class == clang.cindex.StorageClass.STATIC:
		return f"variable '{colored(node.displayname, 'blue')}' is declared static"

def check_goto(node):
	if node.kind == Kind.GOTO_STMT:
		return f"goto statement used"

def check_tabs_spaces_mixed(C_source_filename, C_source_lines, abstract_syntax_tree, args):
	line_indent_type = collections.defaultdict(lambda:set())
	for (line_number, line) in enumerate(C_source_lines):
		indent_type = categorize_line(line)
		if indent_type:
			line_indent_type[indent_type].add(line_number)

	if line_indent_type['mixed']:
		lines_description = describe_line_set(line_indent_type['mixed'])
		print(
f"""{C_source_filename}: {colored('warning', 'red')}: {lines_description} indented with a mixture of tabs and spaces
  This makes the display of your code unreliable including when your tutor is marking for style.
  In COMP1511 we recommend indenting with spaces only, using 4 spaces per indent level.
  Run {colored('1511 replace_tabs '+ C_source_filename,'blue')} to replace the tabs in {C_source_filename} with spaces.""")
		return 1

	for function in abstract_syntax_tree.get_children():
		if (function.kind != Kind.FUNCTION_DECL or
		    not function.location.file or
		    function.location.file != C_source_filename):
			continue
		function_lines = set(range(function.extent.start.line, function.extent.end.line))
		tabbed_lines = function_lines & line_indent_type['tabs']
		spaced_lines = function_lines & line_indent_type['spaces']
		if not tabbed_lines or not spaced_lines:
			continue
		tabbed_description = describe_line_set(tabbed_lines)
		spaced_description = describe_line_set(spaced_lines)
		print(
f"""{C_source_filename}: {colored('warning', 'red')}: function {colored(function.spelling, 'blue')} is indented with a mixture of tabs and spaces:
    {tabbed_description} indented with tabs
    {spaced_description} indented with spaces
  This makes the display of your code unreliable including when your tutor is marking for style.
  In COMP1511 we recommend indenting with spaces only, using 4 spaces per indent level.
  Run {colored('1511 replace_tabs '+ C_source_filename,'blue')} to replace the tabs in {C_source_filename} with spaces.""")
		return 1
		
	return 0

# we could condense ranges here
def describe_line_set(lines):
	max_lines_shown = 5
	line_numbers = sorted(lines)
	description = ",".join(map(str, line_numbers[0:max_lines_shown]))
	if len(line_numbers) == 1:
		return f"line {description} is"
	elif len(line_numbers) > max_lines_shown:
		return f"lines {description}, ... are"
	else:
		return f"lines {description} are"
	
def categorize_line(line):
	if re.match(r'^ +\S', line):
		return "spaces"
	if re.match(r'^\t+\S', line):
		return "tabs"
	if re.match(r'^[ \t]+\S', line):
		return "mixed"	
	
# check bodies of of if/while/for functions consistently indented
# mixes of tabs & spaces not considered
def check_body_indents(args, C_source_file, C_source):
	ast = args.index.parse(C_source_file, unsaved_files=[(C_source_file, C_source)]).cursor
	indents = []
	for node in abstract_syntax_tree_nodes(ast):
		get_indents_node(node, indents)
	indent_counts = collections.Counter(i[1] for i in indents)
	if len(indent_counts) < 2:
		return
	base_indent = indent_counts.most_common(1)[0][0]
	for (line, indent) in sorted(indents):
		if indent != base_indent:
			print(f'{C_source_file}:{line} indented {indent} instead of {base_indent}')
	
def get_indents_node(n, indents):
	#print(f'{"	 " * n.depth} {n.kind.name} {n.location.file}:{n.extent.start.line}:{n.extent.start.column}')
	if n.kind == Kind.COMPOUND_STMT:
		parent = n.parent
		if parent.kind not in [Kind.IF_STMT, Kind.WHILE_STMT, Kind.FOR_STMT, Kind.FUNCTION_DECL]:
			return
		# handle if else if chains
		while parent.parent.kind == Kind.IF_STMT:
			parent = parent.parent
		for child in n.get_children():
			indent = child.extent.start.column - parent.extent.start.column
			indents.append((child.extent.start.line, indent))

# traverse ast nodes from same file (don't go into #includes)
# semantic_parent & lexical parents don't seem to be implement so add own our parent & depth
def abstract_syntax_tree_nodes(node, depth=0, parent=None):
	node.depth = depth
	node.parent = parent
	yield node
	parent_filename = node.location.file.name if node.location.file else node.displayname
	for child in node.get_children():
		child_filename = child.location.file.name if child.location.file else child.displayname
		if child_filename == parent_filename:
			for rn in abstract_syntax_tree_nodes(child, depth + 1, node):
				yield rn

def node_location(n):
	return f'{n.location.file}:{n.extent.start.line}:{n.extent.start.column}'
	
if __name__ == "__main__":
	try:
		sys.exit(1 if main() else 0)
	except KeyboardInterrupt:
		sys.exit(2)
